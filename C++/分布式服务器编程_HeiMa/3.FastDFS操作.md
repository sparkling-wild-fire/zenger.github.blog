# 文件上传下载的实现

## 实现方式

1. 使用多进程方式
    - exec函数族实现，执行fdfs_upload_file等命令
        - execl、execIp
    - 父进程
        - 子进程 =》 执行execIp("fdfs_upload_file","xx",arg,NULL)
        - 有数据输出到终端  =》  输出重定向到日志文件dup2(old,new)
        - 获取文件描述符，子进程将数据库读到内存
            - 数据最终要给到父进程，因为子进程的`代码和数据会被新程序代替`，所以将文件属性写数据库等操作要交给父进程。[exec函数族](https://blog.csdn.net/weixin_43304992/article/details/109627317)
            - 进程间通信 =》 管道pipe  => 读端、写端
            - 所以，重定向时，old是标准输出，new是管道的写端
            - 父进程再从管道的读端读出来
            - 注意这个管道要在创建子进程之前创建，这样父子进程就可以共用同一个管道，避免再新增一个管道用于父进程和子进程通信
        - 父进程从内存中读取到文件数据，再将文件属性什么的存数据库
          <img src="https://cdn.jsdelivr.net/gh/sparkling-wild-fire/picgo@main/blogs/pictures/202304052007167.png" alt="202304052007167" width="450px">

2. 使用fastDFS API实现

先把业务逻辑搞清楚，然后去理解别人的框架，再去看代码，然后改人家的模块代码。比如把人家的main函数修改为自己的API

## 代码实现

操作步骤
1. 创建管道 - pipe
2. 创建子进程
3. 子进程干什么?
   - 写管道, 关闭读端
   - 重定向：将标准输出 -> 管道的写端
   - 执行execl命令, 调用另外的进程fdfs_upload_file
   - 子进程退出
4. 父进程？
   - 读管道， 关闭写端
   - 释放子进程资源 - pcb
   - wait()/ waitpid()

```C++
// 04
int upload_file(const char* confFile, const char* uploadFile, char* fileId,int size){
    // 1. 创建匿名管道
    int fd[2];
    int ret = pipe(fd);
    if (ret == -1){
        perror("pipe error");
        exit(0);
    }
    
    // 2. 创建子进程
    pid_t pid = fork();
    // 如果是子进程
    if(pid == 0){
        // 3. 标准输出重定向 => 管道的写端
        dup2(fd[1],STDOUT_FILEND);
        // 4. 关闭读端
        close(fd[0]);
        // 5. 执行execIp命令
        execIp("fdfs_upload_file","xxx",confFile,uploadFile,NULL);
        // 出错了打印error信息，如果执行成功了，就执行不到这里了
        perror("execIp error");
    }else{     // 父进程
        // 读管道，关闭写端
        close(fd[1]);
//        char buf[1024];
//        read(fd[0],buff,sizeof(buf));
        read(fd[0],fileID,size);
        // 回收子进程的pcb（内核的内存）
        wait(NULL);
    }
}
```

fdfs_upload_file的输出内容将被父进程读取，它的输出内容就是服务器返回的fileID.